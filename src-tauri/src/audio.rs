use crate::models::{AudioFolderStatus, AudioMapping, Fm26Installation};
use std::fs;
use std::path::Path;

/// Reads audio mappings from AudioMappings.txt
#[tauri::command]
pub fn read_audio_mappings(install: Fm26Installation) -> Result<Vec<AudioMapping>, String> {
    let mappings_path = Path::new(&install.audio_inject_path).join("AudioMappings.txt");

    if !mappings_path.exists() {
        return Ok(vec![]);
    }

    let content = fs::read_to_string(&mappings_path)
        .map_err(|e| format!("Failed to read AudioMappings.txt: {}", e))?;

    let mut mappings = Vec::new();

    for line in content.lines() {
        let line = line.trim();

        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('#') || line.starts_with("//") {
            continue;
        }

        // Parse "team_key=folder_name" format
        if let Some((team_key, folder_name)) = line.split_once('=') {
            mappings.push(AudioMapping {
                team_key: team_key.trim().to_string(),
                folder_name: folder_name.trim().to_string(),
            });
        }
    }

    Ok(mappings)
}

/// Writes audio mappings to AudioMappings.txt
#[tauri::command]
pub fn write_audio_mappings(
    install: Fm26Installation,
    mappings: Vec<AudioMapping>,
) -> Result<(), String> {
    let audio_inject_path = Path::new(&install.audio_inject_path);

    // Create directory if it doesn't exist
    if !audio_inject_path.exists() {
        fs::create_dir_all(audio_inject_path)
            .map_err(|e| format!("Failed to create AudioInject directory: {}", e))?;
    }

    // Build the file content
    let mut content = String::new();
    content.push_str("# Audio Mappings\n");
    content.push_str("# Format: team_key=folder_name\n");
    content.push_str("# Use * for default/fallback audio\n");
    content.push_str("# Generated by FM Stadium Tools\n\n");

    for mapping in &mappings {
        content.push_str(&format!("{}={}\n", mapping.team_key, mapping.folder_name));
    }

    // Write to file
    let mappings_path = audio_inject_path.join("AudioMappings.txt");
    fs::write(&mappings_path, content)
        .map_err(|e| format!("Failed to write AudioMappings.txt: {}", e))?;

    Ok(())
}

/// Lists all audio folders (subdirectories) in the AudioInject folder
#[tauri::command]
pub fn list_audio_folders(install: Fm26Installation) -> Result<Vec<String>, String> {
    let audio_inject_path = Path::new(&install.audio_inject_path);

    if !audio_inject_path.exists() {
        return Ok(vec![]);
    }

    let mut folders = Vec::new();

    let entries = fs::read_dir(audio_inject_path)
        .map_err(|e| format!("Failed to read AudioInject directory: {}", e))?;

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_dir() {
            if let Some(name) = path.file_name() {
                let folder_name = name.to_string_lossy().to_string();
                // Skip hidden folders and Music folder
                if !folder_name.starts_with('.') && folder_name != "Music" {
                    folders.push(folder_name);
                }
            }
        }
    }

    // Sort alphabetically
    folders.sort_by(|a, b| a.to_lowercase().cmp(&b.to_lowercase()));

    Ok(folders)
}

/// Inspects an audio folder for required files
#[tauri::command]
pub fn inspect_audio_folder(
    install: Fm26Installation,
    folder_name: String,
) -> Result<AudioFolderStatus, String> {
    let folder_path = Path::new(&install.audio_inject_path).join(&folder_name);

    if !folder_path.exists() {
        return Err(format!("Audio folder does not exist: {}", folder_name));
    }

    // Check for required files
    let anthem_exists = folder_path.join("anthem.wav").exists()
        || folder_path.join("anthem.ogg").exists();
    let goal_home_exists = folder_path.join("goal_home.wav").exists()
        || folder_path.join("goal_home.ogg").exists();
    let goal_away_exists = folder_path.join("goal_away.wav").exists()
        || folder_path.join("goal_away.ogg").exists();

    // List other audio files
    let mut other_files = Vec::new();
    if let Ok(entries) = fs::read_dir(&folder_path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() {
                if let Some(ext) = path.extension() {
                    let ext_str = ext.to_string_lossy().to_lowercase();
                    if ext_str == "wav" || ext_str == "ogg" || ext_str == "mp3" {
                        if let Some(name) = path.file_name() {
                            let file_name = name.to_string_lossy().to_string();
                            // Exclude the standard files from "other" list
                            if !file_name.starts_with("anthem.")
                                && !file_name.starts_with("goal_home.")
                                && !file_name.starts_with("goal_away.")
                            {
                                other_files.push(file_name);
                            }
                        }
                    }
                }
            }
        }
    }

    other_files.sort();

    Ok(AudioFolderStatus {
        folder_name,
        path: folder_path.to_string_lossy().to_string(),
        anthem_exists,
        goal_home_exists,
        goal_away_exists,
        other_files,
    })
}
