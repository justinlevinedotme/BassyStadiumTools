use crate::models::{BundleInfo, Fm26Installation, TeamMapping};
use std::collections::HashSet;
use std::fs;
use std::path::Path;
use chrono::{DateTime, Utc};

/// Lists all .bundle files in the CustomStadium folder
#[tauri::command]
pub fn list_bundles(install: Fm26Installation) -> Result<Vec<BundleInfo>, String> {
    let custom_stadium_path = Path::new(&install.custom_stadium_path);

    if !custom_stadium_path.exists() {
        return Ok(vec![]);
    }

    let mut bundles = Vec::new();

    let entries = fs::read_dir(custom_stadium_path)
        .map_err(|e| format!("Failed to read CustomStadium directory: {}", e))?;

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_file() {
            if let Some(ext) = path.extension() {
                if ext == "bundle" {
                    let file_name = path
                        .file_name()
                        .map(|n| n.to_string_lossy().to_string())
                        .unwrap_or_default();

                    let modified = entry
                        .metadata()
                        .ok()
                        .and_then(|m| m.modified().ok())
                        .map(|t| {
                            let datetime: DateTime<Utc> = t.into();
                            datetime.format("%Y-%m-%d %H:%M:%S").to_string()
                        });

                    bundles.push(BundleInfo {
                        file_name,
                        full_path: path.to_string_lossy().to_string(),
                        exists: true,
                        modified,
                    });
                }
            }
        }
    }

    // Sort by file name
    bundles.sort_by(|a, b| a.file_name.to_lowercase().cmp(&b.file_name.to_lowercase()));

    Ok(bundles)
}

/// Reads team mappings from team_mappings.txt in the StadiumInjection plugin folder
#[tauri::command]
pub fn read_team_mappings(install: Fm26Installation) -> Result<Vec<TeamMapping>, String> {
    let stadium_injection_path = Path::new(&install.plugins_path).join("StadiumInjection");
    let mappings_path = stadium_injection_path.join("team_mappings.txt");

    if !mappings_path.exists() {
        return Ok(vec![]);
    }

    let content = fs::read_to_string(&mappings_path)
        .map_err(|e| format!("Failed to read team_mappings.txt: {}", e))?;

    let mut mappings = Vec::new();

    for line in content.lines() {
        let line = line.trim();

        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('#') || line.starts_with("//") {
            continue;
        }

        // Parse "team_id=bundle_file" or "team_id:bundle_file" format
        let parts: Option<(&str, &str)> = line.split_once('=').or_else(|| line.split_once(':'));

        if let Some((team_id_str, bundle_file)) = parts {
            let team_id_str = team_id_str.trim();
            let bundle_file = bundle_file.trim().to_string();

            if let Ok(team_id) = team_id_str.parse::<i32>() {
                mappings.push(TeamMapping {
                    team_id,
                    bundle_file,
                });
            }
        }
    }

    Ok(mappings)
}

/// Writes team mappings to team_mappings.txt in the StadiumInjection plugin folder with validation
#[tauri::command]
pub fn write_team_mappings(
    install: Fm26Installation,
    mappings: Vec<TeamMapping>,
) -> Result<(), String> {
    // Validate: check for duplicate team IDs
    let mut seen_ids = HashSet::new();
    for mapping in &mappings {
        if !seen_ids.insert(mapping.team_id) {
            return Err(format!("Duplicate team ID: {}", mapping.team_id));
        }
    }

    // Validate: check that bundle files exist
    let custom_stadium_path = Path::new(&install.custom_stadium_path);
    for mapping in &mappings {
        let bundle_path = custom_stadium_path.join(&mapping.bundle_file);
        if !bundle_path.exists() {
            return Err(format!(
                "Bundle file does not exist: {} (for team {})",
                mapping.bundle_file, mapping.team_id
            ));
        }
    }

    // Build the file content
    let mut content = String::new();
    content.push_str("# Stadium Injection - Team to Stadium Mappings\n");
    content.push_str("# Format: TeamID:bundlename.bundle\n");
    content.push_str("# Generated by FM Stadium Tools\n\n");

    for mapping in &mappings {
        content.push_str(&format!("{}:{}\n", mapping.team_id, mapping.bundle_file));
    }

    // Write to StadiumInjection plugin folder
    let stadium_injection_path = Path::new(&install.plugins_path).join("StadiumInjection");

    // Create directory if it doesn't exist
    if !stadium_injection_path.exists() {
        fs::create_dir_all(&stadium_injection_path)
            .map_err(|e| format!("Failed to create StadiumInjection directory: {}", e))?;
    }

    let mappings_path = stadium_injection_path.join("team_mappings.txt");
    fs::write(&mappings_path, content)
        .map_err(|e| format!("Failed to write team_mappings.txt: {}", e))?;

    Ok(())
}
