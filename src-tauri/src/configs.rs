use crate::models::{Fm26Installation, StadiumInjectionConfig};
use std::fs;
use std::path::Path;

const CONFIG_FILE_NAME: &str = "StadiumInjection.cfg";

/// Reads the StadiumInjection plugin configuration
#[tauri::command]
pub fn read_stadium_injection_config(
    install: Fm26Installation,
) -> Result<StadiumInjectionConfig, String> {
    let config_path = Path::new(&install.config_path).join(CONFIG_FILE_NAME);

    if !config_path.exists() {
        return Ok(StadiumInjectionConfig::default());
    }

    let content = fs::read_to_string(&config_path)
        .map_err(|e| format!("Failed to read {}: {}", CONFIG_FILE_NAME, e))?;

    parse_config(&content)
}

/// Writes the StadiumInjection plugin configuration
#[tauri::command]
pub fn write_stadium_injection_config(
    install: Fm26Installation,
    config: StadiumInjectionConfig,
) -> Result<(), String> {
    let config_path_dir = Path::new(&install.config_path);

    // Create config directory if it doesn't exist
    if !config_path_dir.exists() {
        fs::create_dir_all(config_path_dir)
            .map_err(|e| format!("Failed to create config directory: {}", e))?;
    }

    let content = format_config(&config);
    let config_file_path = config_path_dir.join(CONFIG_FILE_NAME);

    fs::write(&config_file_path, content)
        .map_err(|e| format!("Failed to write {}: {}", CONFIG_FILE_NAME, e))?;

    Ok(())
}

/// Lists all .cfg files in the config directory
#[tauri::command]
pub fn list_config_files(install: Fm26Installation) -> Result<Vec<String>, String> {
    let config_path = Path::new(&install.config_path);

    if !config_path.exists() {
        return Ok(vec![]);
    }

    let mut configs = Vec::new();

    let entries = fs::read_dir(config_path)
        .map_err(|e| format!("Failed to read config directory: {}", e))?;

    for entry in entries.flatten() {
        let path = entry.path();
        if path.is_file() {
            if let Some(ext) = path.extension() {
                if ext == "cfg" {
                    if let Some(name) = path.file_name() {
                        configs.push(name.to_string_lossy().to_string());
                    }
                }
            }
        }
    }

    configs.sort();
    Ok(configs)
}

/// Parses BepInEx INI-style config into StadiumInjectionConfig
fn parse_config(content: &str) -> Result<StadiumInjectionConfig, String> {
    let mut config = StadiumInjectionConfig::default();

    for line in content.lines() {
        let line = line.trim();

        // Skip empty lines, comments, and section headers
        if line.is_empty() || line.starts_with('#') || line.starts_with(';') {
            continue;
        }

        // Skip section headers like [General]
        if line.starts_with('[') && line.ends_with(']') {
            continue;
        }

        // Parse key = value
        if let Some((key, value)) = line.split_once('=') {
            let key = key.trim();
            let value = value.trim();

            match key {
                "EnableCustomStadiums" => {
                    config.enable_custom_stadiums = parse_bool(value);
                }
                "ReplaceAllStadiums" => {
                    config.replace_all_stadiums = parse_bool(value);
                }
                "DefaultBundle" => {
                    config.default_bundle = value.to_string();
                }
                "UseCustomPitchDimensions" => {
                    config.use_custom_pitch_dimensions = parse_bool(value);
                }
                "PitchLength" => {
                    config.pitch_length = value.parse().unwrap_or(105);
                }
                "PitchWidth" => {
                    config.pitch_width = value.parse().unwrap_or(68);
                }
                _ => {}
            }
        }
    }

    Ok(config)
}

/// Formats StadiumInjectionConfig to BepInEx INI-style config
fn format_config(config: &StadiumInjectionConfig) -> String {
    let mut content = String::new();

    content.push_str("## StadiumInjection Configuration\n");
    content.push_str("## Generated by FM Stadium Tools\n\n");

    content.push_str("[General]\n\n");

    content.push_str("## Enable custom stadium injection\n");
    content.push_str(&format!(
        "EnableCustomStadiums = {}\n\n",
        format_bool(config.enable_custom_stadiums)
    ));

    content.push_str("## Replace all stadiums with the default bundle (ignores team mappings)\n");
    content.push_str(&format!(
        "ReplaceAllStadiums = {}\n\n",
        format_bool(config.replace_all_stadiums)
    ));

    content.push_str("## Default stadium bundle to use when no team mapping exists\n");
    content.push_str(&format!("DefaultBundle = {}\n\n", config.default_bundle));

    content.push_str("[Pitch]\n\n");

    content.push_str("## Use custom pitch dimensions instead of defaults\n");
    content.push_str(&format!(
        "UseCustomPitchDimensions = {}\n\n",
        format_bool(config.use_custom_pitch_dimensions)
    ));

    content.push_str("## Pitch length in meters (default: 105)\n");
    content.push_str(&format!("PitchLength = {}\n\n", config.pitch_length));

    content.push_str("## Pitch width in meters (default: 68)\n");
    content.push_str(&format!("PitchWidth = {}\n", config.pitch_width));

    content
}

/// Parse boolean from BepInEx config format
fn parse_bool(value: &str) -> bool {
    matches!(value.to_lowercase().as_str(), "true" | "1" | "yes" | "on")
}

/// Format boolean to BepInEx config format
fn format_bool(value: bool) -> &'static str {
    if value {
        "true"
    } else {
        "false"
    }
}
